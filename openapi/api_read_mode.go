/*
Verity API

This application demonstrates the usage of Verity API. 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// ReadModeAPIService ReadModeAPI service
type ReadModeAPIService service

type ApiReadmodeGetRequest struct {
	ctx context.Context
	ApiService *ReadModeAPIService
	selector *string
	readOnlyMode *bool
}

func (r ApiReadmodeGetRequest) Selector(selector string) ApiReadmodeGetRequest {
	r.selector = &selector
	return r
}

func (r ApiReadmodeGetRequest) ReadOnlyMode(readOnlyMode bool) ApiReadmodeGetRequest {
	r.readOnlyMode = &readOnlyMode
	return r
}

func (r ApiReadmodeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReadmodeGetExecute(r)
}

/*
ReadmodeGet Get list of read-only switchpoints or pods

Lists all objects that are in read-only or read-write mode.
The user must choose either "pod" or "switchpoint" as the selector.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReadmodeGetRequest
*/
func (a *ReadModeAPIService) ReadmodeGet(ctx context.Context) ApiReadmodeGetRequest {
	return ApiReadmodeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ReadModeAPIService) ReadmodeGetExecute(r ApiReadmodeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReadModeAPIService.ReadmodeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/readmode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.selector == nil {
		return nil, reportError("selector is required and must be specified")
	}
	if r.readOnlyMode == nil {
		return nil, reportError("readOnlyMode is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "Selector", r.selector, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "Read Only Mode", r.readOnlyMode, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReadmodePutRequest struct {
	ctx context.Context
	ApiService *ReadModeAPIService
	readOnlyMode *bool
	pod *[]string
	switchpoint *[]string
}

func (r ApiReadmodePutRequest) ReadOnlyMode(readOnlyMode bool) ApiReadmodePutRequest {
	r.readOnlyMode = &readOnlyMode
	return r
}

func (r ApiReadmodePutRequest) Pod(pod []string) ApiReadmodePutRequest {
	r.pod = &pod
	return r
}

func (r ApiReadmodePutRequest) Switchpoint(switchpoint []string) ApiReadmodePutRequest {
	r.switchpoint = &switchpoint
	return r
}

func (r ApiReadmodePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReadmodePutExecute(r)
}

/*
ReadmodePut Change read-only mode of switchpoint or pod

Changes the read-only mode of switchpoint or pod.
If "Switchpoint" is provided, the "Pod" parameter is ignored and only the specified switchpoint is updated.
If "Pod" is provided and "Switchpoint" is not, all switchpoints within the specified pod are updated.
If neither parameter is provided, all switchpoints across all pods will be updated.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReadmodePutRequest
*/
func (a *ReadModeAPIService) ReadmodePut(ctx context.Context) ApiReadmodePutRequest {
	return ApiReadmodePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ReadModeAPIService) ReadmodePutExecute(r ApiReadmodePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReadModeAPIService.ReadmodePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/readmode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.readOnlyMode == nil {
		return nil, reportError("readOnlyMode is required and must be specified")
	}

	if r.pod != nil {
		t := *r.pod
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "Pod", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "Pod", t, "form", "multi")
		}
	}
	if r.switchpoint != nil {
		t := *r.switchpoint
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "Switchpoint", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "Switchpoint", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "Read Only Mode", r.readOnlyMode, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
